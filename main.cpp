/*
	Camilo Moreno
	---------------------------------------------
	---------------------------------------------
	This file is my attempt at solving problems from www.projecteuler.coM
*/
#define SIZE 2000000

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <math.h>
#include <array>
using namespace std;


//Problem 001 - - - Multiples of 3 and 5

/*
//Problem 1 - - - Multiples of 3 and 5
//	If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
//	The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.

int main()
{
	int x = 0, sum = 0;
	for (x; x < 1000; x++)
	{
		if ((x % 3) == 0 || (x % 5) == 0)
		{
			sum += x;
		}
	}
	cout << sum << endl;
	return 0;
}
*/


//Problem 002 - - - Even Fibonacci numbers

/*
//	Problem 2 - - - Even Fibonacci numbers
//		Each new term in the Fibonacci sequence is generated by adding the previous two terms.
//		By starting with 1 and 2, the first 10 terms will be :
//		1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//		By considering the terms in the Fibonacci sequence whose values do not exceed four million,
//		find the sum of the even - valued terms.

int main()
{
	int sum = 0, f1 = 1, f2 = 2;
	while (sum <= 4000000)
	{
		if ((f2 % 2) == 0)
		{
			sum += f2;
		}
		f2 = f2 + f1;
		f1 = f2 - f1;
	}
	cout << sum << endl;
	return 0;
}
*/


//Problem 003 - - - Largest prime factor

/*
//Problem 3 - - - Largest prime factor
//	The prime factors of 13195 are 5, 7, 13 and 29.
//	What is the largest prime factor of the number 600851475143?

int main()
{
	double num = 194424731,
		divisor = 2,
		largest = 0,
		primeDiv = 0;
	bool exit = false,
		prime = true;
	do
	{
		if (fmod(num, divisor) == 0)
		{
			for (primeDiv = 2; prime&&!exit; primeDiv++)
			{
				if (fmod(divisor, primeDiv) == 0 && (divisor != primeDiv))
					prime = false;
				if (divisor == primeDiv)
					exit = true;
			}
			if (prime)
			{
				largest = divisor;
				cout << setprecision(20) << largest << endl;

			}
			prime = true;
			exit = false;
		}
		divisor++;
	} while (divisor != num+1);
	cout << largest << endl;
	return 0;
}
*/


//Problem 004 - - - Largest palindrome product

/*
//Problem 4 - - - Largest palindrome product
//	A palindromic number reads the same both ways.
//	The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
//	Find the largest palindrome made from the product of two 3 - digit numbers.

bool checkPaliEVEN(double pali[])
{
	return ((pali[0] == pali[5]) && (pali[1] == pali[4]) && (pali[2] == pali[3]));
}
bool checkPaliODD(double pali[])
{
	return ((pali[1] == pali[5]) && (pali[2] == pali[4]));
}

int main()
{
	double multOne = 100, multTwo = 100, product = 0, largest = 0, remainder = 0, x = 0;
	double Number[6] = {};
	bool palindrome=false;

	for (multOne; multOne < 1000; multOne++)
	{
		for (multTwo = 100; multTwo < 1000; multTwo++)
		{
			product = multOne * multTwo;
			for (int i = 5; i >= 0; i--)
			{
				Number[i] = fmod(product, 10);
				product = floor(product / 10);
			}
			if (Number[0]==0)
				palindrome=checkPaliODD(Number);
			else
				palindrome = checkPaliEVEN(Number);
			if (palindrome && (multOne*multTwo) > largest)
				largest = multOne*multTwo;
		}
	}
	cout << largest << endl;

	return 0;
}
*/


//Problem 005 - - - Smallest multiple

/*
//Problem 5 - - - Smallest multiple
//	Problem 5
//	2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without remainder.
//	What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20 ?

int main()
{
	int answer = 0, x = 0, i = 0;
	bool running = true, divisible = true;

	while (running)
	{
		answer++;
		divisible = true;
		for (x = 1; x <= 20; x++)
		{
			if ((answer%x) != 0)
				divisible = false;
		}
		if (divisible)
			running = false;
	}
	cout << answer << endl;
	return 0;
}
*/


//Problem 006 - - - Sum Square Difference

/*
//Problem 6 - - - Sum Square Difference
//	The sum of the squares of the first ten natural numbers is,
//	1^2 + 2^2 + ... + 10^2 = 385
//	The square of the sum of the first ten natural numbers is,
//	(1 + 2 + ... + 10)^2 = 55^2 = 3025
//	Hence the difference between the sum of the squares of the first ten natural numbers 
//	and the square of the sum is 3025 - 385 = 2640.
//	Find the difference between the sum of the squares of the first one hundred natural numbers
//	and the square of the sum.

int square(int base)
{
	return base*base;
}

int main()
{
	int difference = 0, num1 = 0, num2 = 0, x = 0;

	for (x = 1; x <= 100; x++)
	{
		num1 += square(x);
		num2 += x;
	}
	num2 = square(num2);

	difference = num2 - num1;
	cout << difference << endl;
	return 0;
}
*/


//Problem 007 - - - 10001st prime

/*
//Problem 7 - - - 10001st prime
//	By listing the first six prime numbers : 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
//	What is the 10001st prime number ?

int main()
{
	int answer = 1, half = 0, counter = 0, divisor = 0, x = 0;
	bool prime;
	while (counter < 10001)
	{
		prime = true;
		answer++;
		half = answer / 2;
		x = 2;
		while (x <= half)
		{
			if ((answer%x) == 0)
				prime = false;
			x++;
		}
		if (prime)
		{
			counter++;
			if (counter == 10001)
				cout << answer << endl;
		}
	}
	return 0;
}
*/


//Problem 008 - - - Largest product in a series

/*
//Problem 8 - - - Largest product in a series
//	The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
//
//		731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495
//	4595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722
//	3831136222989342338030813533627661428280644448664523874930358907296290491560440772390713810515859307960866701724271218839987
//	9790879227492190169972088809377665727333001053367881220235421809751254540594752243525849077116705560136048395864467063244157
//	2215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319
//	9890008895243450658541227588666881164271714799244429282308634656748139191231628245861786645835912456652947654568284891288314
//	2607690042242190226710556263211111093705442175069416589604080719840385096245544436298123098787992724428490918884580156166097
//	9191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
//
//	Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

int main()
{
	string	theNumber = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450",
		digits = "";
	bool done = false;
	double largestProduct = 0, smallerProduct;
	int count = 0, n;
	while (!done)
	{
		count = 13;
		smallerProduct = 1;
		n = theNumber.size()-1;
		while (count > 0)
		{
			smallerProduct = smallerProduct * (theNumber[n]-48);
			n--;
			count--;
		}
		theNumber.pop_back();
		
		if (smallerProduct > largestProduct)
			largestProduct = smallerProduct;

		if (theNumber.size()<13)
			done = true;
	}
	
	cout << endl << fixed << largestProduct << endl;

	return 0;
}
*/


//Problem 009 - - - Special Pythagorean triplet

/*
//Problem 9 - --Special Pythagorean triplet
//	A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//
//			a^2 + b^2 = c^2
//
//	For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
//
//	There exists exactly one Pythagorean triplet for which a + b + c = 1000.
//	Find the product abc.

int main()
{
	int a = 0, b = 1, c = 2;
	bool done = false;

	while (!done&&a < 1000)
	{
		b = 1;
		a++;
		while (!done&&b < 1000)
		{
			c = 2;
			b++;
			while (!done && c < 1000)
			{
				if ((a + b + c == 1000) && (a < b < c) && (a*a + b*b == c*c))
					done = true;
				else
					c++;
			}
		}
	}
	cout << "The variables are a = " << a << " b = " << b << " and c = " << c << "." << endl;
	cout << "The product a x b x c = " << a*b*c << endl;

	return 0;
}
*/


//Problem 010 - - - Summation of Primes

/*
//Problem 10 - - - Summation of Primes
// The sum of all primes below 10 is 2 + 3 + 5 + 7 = 17
//Find the sum of all primes below two million.


void markMultiples(vector<bool> *v, int a, int n)
{
	int i = 2, num;
	while ((num = i*a) <= n)
	{
		(*v)[num - 1] = 1; // minus 1 because index starts from 0.
		++i;
	}
}

// A function to print all prime numbers smaller than n
void SieveOfEratosthenes()
{
	double sum = 2;
	// Create an array and initialize all elements as 0
	vector<bool> mArray;
	for (int x = 0; x < SIZE/2; x++){
		mArray.push_back(false);
		mArray.push_back(true);
	}
	mArray[0] = true; 
	mArray[1] = false;
	//Following property is maintained in the below for loop
	//arr[i] == 0 means i + 1 is prime
	//arr[i] == 1 means i + 1 is not prime
	
	for (int i = 2; i<SIZE; i+=2)
	{
		if (mArray[i] == false)
		{
			//(i+1) is prime, print it and mark its multiples
			sum = sum + i + 1;
			markMultiples(&mArray, i + 1, SIZE);
		}
	}
	cout.precision(15);
	cout << sum << endl;
}

// Driver Program to test above function
int main()
{
	cout << "Sum of primes below 2 million: ";
	SieveOfEratosthenes();
	return 0;
}
*/


//Problem 011 - - - Largest Product in a Grid

/*
//In the 20×20 grid below, four numbers along a diagonal line have been marked in (red).
			//08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
			//49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
			//81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
			//52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
			//22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
			//24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
			//32 98 81 28 64 23 67 10(26)38 40 67 59 54 70 66 18 38 64 70
			//67 26 20 68 02 62 12 20 95(63)94 39 63 08 40 91 66 49 94 21
			//24 55 58 05 66 73 99 26 97 17(78)78 96 83 14 88 34 89 63 72
			//21 36 23 09 75 00 76 44 20 45 35(14)00 61 33 97 34 31 33 95
			//78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
			//16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
			//86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
			//19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
			//04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
			//88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
			//04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
			//20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
			//20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
			//01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
//
//...The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
//What is the greatest product of four adjacent numbers in
//     the same direction(up, down, left, right, or diagonally) in the 20×20 grid ?

int main(){
	string numbers = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
	return 0;
}
*/
